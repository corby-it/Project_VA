//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/opencv.hpp>
//C
#include <stdio.h>
#include <stdlib.h>
//C++
#include <iostream>
#include <iomanip>
#include <sstream>

using namespace cv;
using namespace std;

// ------------------ COSTANTI --------------------------------
// Risoluzione a cui viene resizato qualsiasi frame
const Size STD_SIZE(640, 480);

// ------------------ VARIABILI -------------------------------
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

// Variabili utilizzate nell'estrazione dell'area di interesse
int leftX = 0, rightX = 0;

// Informazioni sul frame corrente processato
int frameCounter = 0;

// Inizializzazione utile nel caso non trovi contorni
Mat3b frameResized = Mat3b(STD_SIZE.height, 250);

// Dichiarazione delle funzioni
void help();
void processVideo(char* videoFilename);


// ------------------ MAIN -------------------------------
int main(int argc, char* argv[])
{
	//print help information
	help();

	////check for the input parameter correctness
	//if(argc != 3) {
	//    cerr <<"Incorret input list" << endl;
	//    cerr <<"exiting..." << endl;
	//    return EXIT_FAILURE;
	//}

	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG");
	namedWindow("FG Mask MOG 2");

	//create Background Subtractor objects
	pMOG= new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

	if(strcmp(argv[1], "-vid") == 0) {
		//input data coming from a video
		processVideo(argv[2]);
	}
	else {
		//error in reading input parameters
		cerr <<"Please, check the input parameters." << endl;
		cerr <<"Exiting..." << endl;
		return EXIT_FAILURE;
	}

	// pause, wait for key
	system("pause");

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

// ------------------ VIDEO PROCESSING -------------------------------
void processVideo(char* videoFilename) {

	// Hog detector
	HOGDescriptor hog;
	hog.setSVMDetector(HOGDescriptor::getDefaultPeopleDetector());

	//create the capture object
	VideoCapture capture(videoFilename); // o 0 per webcam!
	if(!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while( (char)keyboard != 'q' && (char)keyboard != 27 ) {
		//read the current frame
		if(!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}

		// Resize dei frame in input alla dimensione standard
		resize(frame, frame, STD_SIZE);

		// BACKGROUND SUBTRACTION --------------------------------------------
		pMOG->operator()(frame, fgMaskMOG, 0.1);
		pMOG2->operator()(frame, fgMaskMOG2, 0.1);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
			cv::Scalar(255,255,255), -1);
		ss << capture.get(CV_CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

		// disegna una bounding box BLU attorno alle zone di foreground
		std::vector<std::vector<cv::Point> > contours;
		std::vector<cv::Vec4i> hierarchy;
		findContours( fgMaskMOG, contours, hierarchy, RETR_CCOMP, cv::CHAIN_APPROX_TC89_KCOS);
		for ( size_t i=0; i<contours.size(); ++i ){

			Rect brect = cv::boundingRect(contours[i]);

			// disegna un rettangolo solo se è più grande di (frame.rows/3) (soglia a caso)
			if(true/*brect.height > (frame.rows/3)*/){

				int rectCenterX = brect.x + brect.width/2;
				int rectCenterY = brect.y + brect.height/2;

				leftX = rectCenterX - 125;
				if(leftX < 0)
					leftX = 0;
				rightX = rectCenterX + 125;
				if(rightX > STD_SIZE.width)
					rightX = STD_SIZE.width;

				Rect newRect = Rect(leftX, 0, (rightX-leftX), STD_SIZE.height);

				frameResized = Mat3b(STD_SIZE.height, 250);
				frameResized = frame(newRect);

				
				rectangle(frame, newRect, Scalar(255,0,0));
			}
				/*stringstream ss;
				ss << "tmp/" << frameCounter << ".jpg";
				imwrite(ss.str(), frameResized);*/
		}

		// HOG PEOPLE DETECTION -----------------------------------------------
		vector<Rect> found, found_filtered;
		double t = (double)getTickCount();
		// run the detector with default parameters. to get a higher hit-rate
		// (and more false alarms, respectively), decrease the hitThreshold and
		// groupThreshold (set groupThreshold to 0 to turn off the grouping completely).
		hog.detectMultiScale(frameResized, found, 0, Size(8,8), Size(0,0), 1.05, 2);
		t = (double)getTickCount() - t;
		cout << "detection time = " << t*1000./cv::getTickFrequency() << " - found objects: " << found.size() << endl;

		size_t i, j;
		for( i = 0; i < found.size(); i++ ) {
			Rect r = found[i];
			for( j = 0; j < found.size(); j++ )
				if( j != i && (r & found[j]) == r)
					break;
			if( j == found.size() )
				found_filtered.push_back(r);
		}

		for( i = 0; i < found_filtered.size(); i++ ){
			Rect r = found_filtered[i];
			// the HOG detector returns slightly larger rectangles than the real objects.
			// so we slightly shrink the rectangles to get a nicer output.
			r.x += cvRound(r.width*0.1) + leftX;
			r.width = cvRound(r.width*0.8);
			r.y += cvRound(r.height*0.07);
			r.height = cvRound(r.height*0.8);
			rectangle(frame, r.tl(), r.br(), cv::Scalar(0,255,0), 1);
		}

		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("frameResized", frameResized);
		imshow("FG Mask MOG", fgMaskMOG);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey( 1 );

		frameCounter++;

	}

	//delete capture object
	capture.release();


}

void help()
{
	cout
		<< "--------------------------------------------------------------------------"  << endl
		<< "Usage:"                                                                      << endl
		<< "./bs {-vid <video filename>|-img <image filename>}"                          << endl
		<< "for example: ./bs -vid video.avi"                                            << endl
		<< "or: ./bs -img /data/images/1.png"                                            << endl
		<< "--------------------------------------------------------------------------"  << endl
		<< endl;
}